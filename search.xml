<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java.util.stream</title>
      <link href="2020/10/31/java.util.stream/"/>
      <url>2020/10/31/java.util.stream/</url>
      
        <content type="html"><![CDATA[<h1 id="java-util-stream"><a href="#java-util-stream" class="headerlink" title="java.util.stream"></a>java.util.stream</h1><h2 id="Stream的常见用法："><a href="#Stream的常见用法：" class="headerlink" title="Stream的常见用法："></a>Stream的常见用法：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">                .map(e -&gt; e + <span class="number">1</span>)</span><br><span class="line">                .sorted((e1,e2) -&gt; e1 - e2)</span><br><span class="line">                .filter(t -&gt; t &gt; <span class="number">3</span>)</span><br><span class="line">                .forEach(e -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，首先是用of方法先建一个Stream，然后链式调用。这里面由Stream.of方法产生的Stream对象是头结点，map、sorted、filter是中间操作，每进行一次中间操作就会产生一个流对象结点(stage:Stream)，forEach是结束操作。操作总结如下：</p><table>    <tbody>        <tr>            <td colspan="3" align="center" border="0">Stream操作分类</td>        </tr>        <tr>            <td rowspan="2" border="1">中间操作(Intermediate operations)</td>            <td>无状态(Stateless)</td>            <td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td>        </tr>        <tr>            <td>有状态(Stateful)</td>            <td>distinct() sorted() sorted() limit() skip() </td>        </tr>        <tr>            <td rowspan="2" border="1">结束操作(Terminal operations)</td>            <td>非短路操作</td>            <td>forEach() forEachOrdered() toArray() reduce() colect() max() min() count()            </td>        </tr>        <tr>            <td>短路操作(short-circuiting)</td>            <td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td>        </tr>    </tbody></table><p>看完了操作，我们来看一下Stream体系的组织架构。</p><h2 id="Stream架构"><a href="#Stream架构" class="headerlink" title="Stream架构"></a>Stream架构</h2><p><img src="java.util.stream/Stream%E6%9E%B6%E6%9E%84.png" class="lazyload" data-srcset="java.util.stream/Stream%E6%9E%B6%E6%9E%84.png" srcset="data:image/png;base64,666" alt="Lena"></p><p>上面表格里面的方法，基本上都是在ReferencePipeline这个类里面实现的</p><p>接着，我们根据上面的流应用的例子结合源码来看一下每一步干了什么事，生成了什么对象（注意结合体系架构图看，更清晰）。</p><p>首先是：</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="Stream-of-T…-values"><a href="#Stream-of-T…-values" class="headerlink" title="Stream.of(T… values)"></a>Stream.of(T… values)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Stream接口中的一个of方法，用来生成一个流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Arrays类中的方法，调用同类中的stream方法继续执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stream(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Arrays类中的方法，调用StreamSupport中的stream方法继续执行</span></span><br><span class="line"><span class="comment">// 在调用stream方法之前，先用传进来的参数调用spliterator方法生成数据源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array, <span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(array, startInclusive, endExclusive), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Arrays类中的方法，调用Spliterators类中的spliterator方法继续执行</span></span><br><span class="line"><span class="comment">// 因为是Arrays类中的方法，所以生成的这个数据源需要带着符合数组的一些特征值（特征值之间用或操作）</span></span><br><span class="line"><span class="comment">// 这里就传递了两个特征值：Spliterator.ORDERED（有序）和Spliterator.IMMUTABLE（不可变）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">(T[] array, <span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(array, startInclusive, endExclusive,</span><br><span class="line">                                    Spliterator.ORDERED | Spliterator.IMMUTABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. Spliterators类中的方法，真正用来生成spliterator的方法，这里生成了一个ArraySpliterator</span></span><br><span class="line"><span class="comment">// 根据这个类的名字我们就能知道，这个类是各种spliterator类和生成各种spliterator的集合。所以各种</span></span><br><span class="line"><span class="comment">// 生成spliterator的操作最终都是由这个类的各种方法完成的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">(Object[] array, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,<span class="keyword">int</span> additionalCharacteristics)</span> </span>&#123;</span><br><span class="line">    checkFromToBounds(Objects.requireNonNull(array).length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArraySpliterator&lt;&gt;(array, fromIndex, toIndex, additionalCharacteristics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回到3. 我们看一下StreamSupport中的stream方法。通过该类名可得知，该类是为流提供支持的，比如：</span></span><br><span class="line"><span class="comment">// 生成流管道结点</span></span><br><span class="line"><span class="comment">// 该方法接受两个参数：数据源和是否并行操作，显然调用的时候没有要求并行操作，所以parallel是false</span></span><br><span class="line"><span class="comment">// 该方法new了一个Head的流结点。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="keyword">boolean</span> parallel)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReferencePipeline.Head&lt;&gt;(spliterator,</span><br><span class="line">                       StreamOpFlag.fromCharacteristics(spliterator), parallel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的操作中出现了数据源，我们来看看这个spliterator到底是个什么东西，<a href="#Spliterator">Spliterator</a>。</p><p>通过上面一系列的操作，我们得到了一个Head对象，下面我们来看一下Head类</p><h3 id="Head类"><a href="#Head类" class="headerlink" title="Head类"></a>Head类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span>&lt;<span class="title">E_IN</span>, <span class="title">E_OUT</span>&gt; <span class="keyword">extends</span> <span class="title">ReferencePipeline</span>&lt;<span class="title">E_IN</span>, <span class="title">E_OUT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constructor for the source stage of a Stream.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> source &#123;<span class="doctag">@code</span> Supplier&lt;Spliterator&gt;&#125; describing the stream</span></span><br><span class="line"><span class="comment">         *               source</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> sourceFlags the source flags for the stream source, described</span></span><br><span class="line"><span class="comment">         *                    in &#123;<span class="doctag">@link</span> StreamOpFlag&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    Head(Supplier&lt;? extends Spliterator&lt;?&gt;&gt; source,</span><br><span class="line">         <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">        <span class="keyword">super</span>(source, sourceFlags, parallel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Constructor for the source stage of a Stream.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> source &#123;<span class="doctag">@code</span> Spliterator&#125; describing the stream source</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> sourceFlags the source flags for the stream source, described</span></span><br><span class="line"><span class="comment">         *                    in &#123;<span class="doctag">@link</span> StreamOpFlag&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    Head(Spliterator&lt;?&gt; source,</span><br><span class="line">         <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">        <span class="keyword">super</span>(source, sourceFlags, parallel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">opIsStateful</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Sink&lt;E_IN&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimized sequential terminal operations for the head of the pipeline</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isParallel()) &#123;</span><br><span class="line">            sourceStageSpliterator().forEachRemaining(action);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.forEach(action);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isParallel()) &#123;</span><br><span class="line">            sourceStageSpliterator().forEachRemaining(action);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.forEachOrdered(action);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上代码可以看到，Head类啥也没干，就算重写了父类方法，也只是用super调用父类的方法。而根据代码中的英文注释可以得出，Head类对象就是一个管道流的起点，本身不包含对数据源的操作。下面我们通过他的构造方法看看他是怎么成为流的头结点的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接super父类构造方法</span></span><br><span class="line">Head(Spliterator&lt;?&gt; source, <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">    <span class="keyword">super</span>(source, sourceFlags, parallel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类直接再父类</span></span><br><span class="line">ReferencePipeline(Spliterator&lt;?&gt; source, <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">    <span class="keyword">super</span>(source, sourceFlags, parallel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到new Head的时候最终起效果的是爷爷类的构造方法</span></span><br><span class="line">AbstractPipeline(Spliterator&lt;?&gt; source, <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">    <span class="keyword">this</span>.previousStage = <span class="keyword">null</span>;        <span class="comment">// 直接设置前指针为null（自己就是源）</span></span><br><span class="line">    <span class="keyword">this</span>.sourceSpliterator = source;  <span class="comment">// 设置数据源</span></span><br><span class="line">    <span class="keyword">this</span>.sourceStage = <span class="keyword">this</span>;          <span class="comment">// 设置源stage为当前stage（因为自己就是源）</span></span><br><span class="line">    <span class="keyword">this</span>.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;</span><br><span class="line">    <span class="keyword">this</span>.combinedFlags = (~(sourceOrOpFlags &lt;&lt; <span class="number">1</span>)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;</span><br><span class="line">    <span class="keyword">this</span>.depth = <span class="number">0</span>;  <span class="comment">// 源stage深度为0</span></span><br><span class="line">    <span class="keyword">this</span>.parallel = parallel;         <span class="comment">// 设置并行标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的构造方法很清楚地看到，当调用生成流方法的时候，会返回一个Head stage，而在new这个stage的时候通过调用它爷爷的一个构造方法，使这个stage成为了流的头。</p><p>构造出一个流管道对象之后，就可以进行流相应的操作了。我们接着代码往下看，流对象调用了一个map方法（映射的意思），传进了一个lambda表达式，也即一个匿名内部类对象。我们来看一下，调用map的背后到底做了哪些操作</p><h3 id="流stage的map方法"><a href="#流stage的map方法" class="headerlink" title="流stage的map方法"></a>流stage的map方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReferencePipeline类</span></span><br><span class="line"><span class="comment"> * map方法为一个泛型方法。mapper接受P_OUT类型，返回R类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="comment">// 返回一个StatelessOp的匿名子类对象，因为map方法是每个元素是独立处理的，没有相互的关系</span></span><br><span class="line">    <span class="comment">// 这里的this表示调用这个方法的对象，也即上流结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="comment">// 重写了父类的的opWrapSink方法，这个方法定义在AbstractPipeline中（该类的曾祖父类）</span></span><br><span class="line">        <span class="comment">// 方法用来生成一个Sink类（子类）对象</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这个方法根据参数sink，构造一个Sink.ChainedReference的匿名内部类对象并返回</span></span><br><span class="line">            <span class="comment">// 原理：ChainedReference中维护了一个Sink对象downstream，在构造方法中将sink赋值给它</span></span><br><span class="line">            <span class="comment">// 即当前返回的Sink对象包含了另一个Sink对象，这个对象即是管道的下游Sink</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">              <span class="comment">// 这个匿名内部类重写了accept方法，先用当前Sink的mapper对数据进行处理，然后交给下游Sink继续处理</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    downstream.accept(mapper.apply(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：mapper只是当前map方法的一个形参，理应当随着这个方法的结束而死亡，为什么在后面Sink对象能使用该mapper呢，参见<a href="D:\TyporaDocument\Java\内部类\内部类.md">局部内部类</a>。</p><p>这个方法其实挺简单的，就是new了一个StatelessOp的匿名内部类并返回，至于里面两层的重写方法，因为还没有调用到，所以不急着讨论。前面说到，每调用一个中间操作就会相应地生成一个流结点，那我们就来看看这新生成的结点是怎么与前面的结点产生联系。下面来看一下StatelessOp类的构造方法</p><h3 id="StatelessOp类的构造方法"><a href="#StatelessOp类的构造方法" class="headerlink" title="StatelessOp类的构造方法"></a>StatelessOp类的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个构造方法有三个参数</span></span><br><span class="line"><span class="comment"> * upstream: 上流结点（stage）</span></span><br><span class="line"><span class="comment"> * inputShape：这个流结点处理的数据的类型（StreamShape是enum，其中REFERENCE表示引用类型）</span></span><br><span class="line"><span class="comment"> * opFlags：操作标识符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">StatelessOp(AbstractPipeline&lt;?, E_IN, ?&gt; upstream,</span><br><span class="line">            StreamShape inputShape,</span><br><span class="line">            <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="comment">// 直接调用父类的构造方法</span></span><br><span class="line">    <span class="keyword">super</span>(upstream, opFlags);</span><br><span class="line">    <span class="keyword">assert</span> upstream.getOutputShape() == inputShape;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类构造方法</span></span><br><span class="line">ReferencePipeline(AbstractPipeline&lt;?, P_IN, ?&gt; upstream, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="comment">// 又直接交给父类</span></span><br><span class="line">    <span class="keyword">super</span>(upstream, opFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终进行实际操作的构造方法</span></span><br><span class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="comment">// 检查一下传进来的stage是否已连接或者已被消费</span></span><br><span class="line">    <span class="keyword">if</span> (previousStage.linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">  <span class="comment">// 把上流stage的linkedOrConsumed标识符设置为true</span></span><br><span class="line">    previousStage.linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 上流stage的next指针设置成当前正在new的stage，</span></span><br><span class="line">    previousStage.nextStage = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// 把当前stage的previous指针设置成上流stage</span></span><br><span class="line">    <span class="keyword">this</span>.previousStage = previousStage;</span><br><span class="line">    <span class="comment">// 设置一些属性（还没琢磨明白这些属性具体的内容，暂且不表）</span></span><br><span class="line">    <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class="line">    <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags,previousStage.combinedFlags);</span><br><span class="line">    <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class="line">    <span class="keyword">if</span> (opIsStateful())</span><br><span class="line">        sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 把depth + 1，头结点的depth为0</span></span><br><span class="line">    <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在new出这个新的stage的时候，就已经把这个stage挂到了流管道的末尾了，并且可以看到，<strong>这个流管道是以双向链表组织起来的</strong>。从这个我们就可以类比推出，每一个中间操作都只会直接返回一个StatelessOp或者StatefulOp匿名内部类（匿名子类）对象，并且在new的过程中把这个对象挂到流管道的末尾。从这，可以看出中间操作并没有执行具体的操作，是一种<strong>懒加载的模式</strong>。</p><p>那么问题来了，是什么时机触发整个流开始执行呢，执行过程又是怎样的呢？第一个问题，我们基本上可以推断出在调用结束操作的时候，触发了整个流的执行。我们来看看源码中是怎触发的，怎么执行的。下面以forEach结束操作为例</p><h3 id="流stage的forEach方法"><a href="#流stage的forEach方法" class="headerlink" title="流stage的forEach方法"></a>流stage的forEach方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferencePipeline类中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> P_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先调用了ForEachOps中的makeRef的方法，根据上述内容推断，这个方法应该是创建了一个流尾stage</span></span><br><span class="line">    <span class="comment">// evaluate方法应该就是触发执行的方法</span></span><br><span class="line">    evaluate(ForEachOps.makeRef(action, <span class="keyword">false</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ForEachOps中的makeRef方法，该方法返回一个TerminalOp对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">TerminalOp&lt;T, Void&gt; <span class="title">makeRef</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">boolean</span> ordered)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="comment">// 直接new一个ForEachOp.OfRef类对象返回，似乎初步验证了上面的猜想</span></span><br><span class="line">    <span class="comment">// 可以看出ForEachOp是Terminal类的子类，OfRef是ForEachOp的内部类也是子类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForEachOp.OfRef&lt;&gt;(action, ordered);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OfRef构造方法</span></span><br><span class="line">OfRef(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer, <span class="keyword">boolean</span> ordered) &#123;</span><br><span class="line">    <span class="keyword">super</span>(ordered);</span><br><span class="line">    <span class="comment">// 只是把具体操作consumer封装进了成员变量中，没有其他过多的操作</span></span><br><span class="line">    <span class="keyword">this</span>.consumer = consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从OfRef的构造方法可以看出，它只是封装了具体操作，也没有把stage挂到管道流的末尾，并且从继承关系上可以看出OfRef类是一个Sink类，跟管道流的stage不在一个体系内，压根也不能挂到管道流上。那么前面的管道流与这个Sink有什么关系呢？</p><p>注意到管道流stage都重写了父类的opWrapSink方法，通过传进来的Sink返回一个新的Sink，结合管道流是一个双向链表，似乎可以发现些什么：结束操作直接创建了一个Sink对象，并触发管道流的执行操作，执行过程：</p><ol><li>首先用管道流尾stage（<strong>因为结束操作是管道流尾stage调用的</strong>），以结束操作返回的Sink对象为参数，返回一个新的Sink，这个新的Sink封装了结束操作返回的Sink。从链尾遍历回链头，不断返回的Sink做参数返回新Sink</li><li>Sink对象封装了每一个stage具体的操作</li><li>最后的执行过程就是调用Sink对象中的方法</li></ol><p>来看一下我们上述的分析是否正确</p><h3 id="流stage的evaluate方法"><a href="#流stage的evaluate方法" class="headerlink" title="流stage的evaluate方法"></a>流stage的evaluate方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractPipeline中的方法，并且为final，所有管道流stage都有、都是这个方法，不可被重写</span></span><br><span class="line"><span class="comment"> * 本例中terminalOp为ForEachOp.OfRef对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> &lt;R&gt; <span class="function">R <span class="title">evaluate</span><span class="params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">getOutputShape</span><span class="params">()</span> </span>== terminalOp.inputShape();</span><br><span class="line">    <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 判断是否是并行流</span></span><br><span class="line">    <span class="keyword">return</span> isParallel()</span><br><span class="line">        <span class="comment">// 并行流执行并行方法</span></span><br><span class="line">        ? terminalOp.evaluateParallel(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()))</span><br><span class="line">        <span class="comment">// 串行流执行串行方法（这里执行的串行方法）</span></span><br><span class="line">        <span class="comment">// 注意：这里的this是调用evaluate的对象，这里为流管道尾stage</span></span><br><span class="line">        : terminalOp.evaluateSequential(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ForEachOp中的方法，重写自TerminalOp类，也即每个TerminalOp子类都有这个执行方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;S&gt; <span class="function">Void <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Spliterator&lt;S&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用管道尾stage的wrapAndCopyInto方法。这个this是调用evaluateSequential的对象，即为terminalOp</span></span><br><span class="line">    <span class="keyword">return</span> helper.wrapAndCopyInto(<span class="keyword">this</span>, spliterator).get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractPipeline中的方法，并且为final，所有管道流stage都有、都是这个方法，不可被重写</span></span><br><span class="line"><span class="comment"> * 该方法调用了两个方法，首先是wrapSink，通过wrapSink返回的sink调用copyInto执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN, S extends Sink&lt;E_OUT&gt;&gt; <span class="function">S <span class="title">wrapAndCopyInto</span><span class="params">(S sink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);</span><br><span class="line">    <span class="keyword">return</span> sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的分析，我们能看到，wrapSink就是我们上面分析的 1. 中包装Sink的方法，而copyInto就是执行最后返回Sink</p><h3 id="流stage的wrapSink方法"><a href="#流stage的wrapSink方法" class="headerlink" title="流stage的wrapSink方法"></a>流stage的wrapSink方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractPipeline中的方法，并且为final，所有管道流stage都有、都是这个方法，不可被重写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(sink);</span><br><span class="line">    <span class="comment">// 链尾向向链头迭代，用深度depth进行控制</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        <span class="comment">// 调用循环中当前stage的opWrapSink方法把管道流下游封装成一个新的sink，并用这个sink做参数继续封装（套娃）</span></span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以开头调用map方法返回的stage为例，看一下这个stage中opWrapSink方法干了些啥。</p><h3 id="map方法返回的stage的opWrapSink方法"><a href="#map方法返回的stage的opWrapSink方法" class="headerlink" title="map方法返回的stage的opWrapSink方法"></a>map方法返回的stage的opWrapSink方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体Stage中的方法，重写自AbstractPipeline类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; sink)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法根据参数sink，构造一个Sink.ChainedReference的匿名内部类对象并返回</span></span><br><span class="line">    <span class="comment">// 原理：ChainedReference中维护了一个Sink对象downstream，在构造方法中将sink赋值给它</span></span><br><span class="line">    <span class="comment">// 即当前返回的Sink对象包含了另一个Sink对象，这个对象即是管道的下游Sink</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">        <span class="comment">// 这个匿名内部类重写了accept方法，先用当前Sink的mapper对数据进行处理，然后交给下游Sink继续处理</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">            downstream.accept(mapper.apply(u));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装完成后，返回最终的sink给copyInto方法使用</p><h3 id="copyInto方法"><a href="#copyInto方法" class="headerlink" title="copyInto方法"></a>copyInto方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractPipeline中的方法，并且为final，所有管道流stage都有、都是这个方法，不可被重写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(wrappedSink);</span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        <span class="comment">// 调用sink的begin方法</span></span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">        <span class="comment">// 调用sink的accept方法（由于sink本身是cosumer类型的，而forEachRemaining方法会为每个元素调用一次accpet方法）</span></span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">        <span class="comment">// 调用sink的end方法</span></span><br><span class="line">        wrappedSink.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面方法中，使用到了sink的是三个方法：begin、accept、end，这个接口采取了模版方法的设计模式，这三个方法要按顺序调用。</p><h3 id="Sink接口"><a href="#Sink接口" class="headerlink" title="Sink接口"></a>Sink接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要有三类方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要进行一些初始化作用，比如排序操作里面的new数组</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要进行一些结束操作，比如排序里面的排序，并调用下游sink begin方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要进行我们传进去的lambda表达式的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;called wrong accept method&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这三个方法都是default修饰，并不需要全部重写。一般简单的操作，比如map只需重写accept方法，另外两个直接使用接口里面的默认空方法；复杂点的操作比如sort，需要重写三个方法</p><p>上游sink在调用这三个方法时，会在合适的时机调用下游sink的方法，这样就形成了链式调用，例如map方法返回的sink和sort方法中返回的sink：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map方法返回的sink只重写了accept方法。会在调用accept方法处理完数据后，调用下游sink的accept方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">    downstream.accept(mapper.apply(u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort方法返回额sink，重写了模版方法的三个方法。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SizedRefSortingSink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRefSortingSink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    SizedRefSortingSink(Sink&lt;? <span class="keyword">super</span> T&gt; sink, Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">super</span>(sink, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// begin方法接受上游sink传来的数据源的数组长度，并new出一个数组来，为接受数据做准备</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= Nodes.MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Nodes.BAD_SIZE);</span><br><span class="line">        array = (T[]) <span class="keyword">new</span> Object[(<span class="keyword">int</span>) size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际上的排序是由end方法来完成的，并且触发下游的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays.sort(array, <span class="number">0</span>, offset, comparator);</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 排完序后，调用下游的begin方法，初始化下游的数据结合。例如</span></span><br><span class="line"><span class="comment">         * 下游如果是：</span></span><br><span class="line"><span class="comment">        *     sort的sink：那么下游就会new一个数组出来，为接收数据做准备；</span></span><br><span class="line"><span class="comment">         *     map的sink：那么这个方法将什么也不做，也不需要做。因为map的sink没有重写begin方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        downstream.begin(offset);</span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 对每一个元素调用下游的accept方法。</span></span><br><span class="line"><span class="comment">         * 下游如果是：</span></span><br><span class="line"><span class="comment">        *     sort的sink：那么下游就会把当前元素放入数组；</span></span><br><span class="line"><span class="comment">         *     map的sink：将会调用封装的lambda表达式对数据进行处理，再调用下下游的accept方法</span></span><br><span class="line"><span class="comment">        */</span>   </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; offset; i++)</span><br><span class="line">                downstream.accept(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; offset &amp;&amp; !downstream.cancellationRequested(); i++)</span><br><span class="line">                downstream.accept(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后调用下游的end方法</span></span><br><span class="line">        downstream.end();</span><br><span class="line">        <span class="comment">// 当前数组置空，好被gc</span></span><br><span class="line">        array = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// accept方法在这个sink中，只是接受了上游sink传递来的数据并存储在begin方法new出的数组中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        array[offset++] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，其实有一个疑问：为什么每一个stage已经包含了操作，而且stage也是双向链表连接起来了，不直接使用stage处理完，调用下一个stage的处理呢？这是因为每一个stage的操作都是不一样的，比如map方法返回的stage，就只用lambda遍历每一个元素进行相应的处理就好，而sort方法返回的stage需要先new一个数组，然后把每一个元素填入到数组中，然后再调用数组排序。这样每一个stage的涉及到的操作和方法并不一样，调用起来很复杂。为了能很好的完成上下游之间联动，就抽象出了三个模版方法。上游只需要在合适的时机按顺序调用下游的三个模版方法就好了（因为每一个sink都有这三个方法，上游知道下游必定有这三个方法，放心调用就完事了）。</p><p>上面说了这么多，流操作的基本流程已经理清楚了，下面一图以蔽之：</p><img src="java.util.stream/stream%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="lazyload" data-srcset="java.util.stream/stream%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="data:image/png;base64,666" alt="Lena" style="zoom:50%;" /><p><strong>补</strong>：补一个流的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 好好研究这个代码，很有价值</span><br><span class="line">Arrays.stream(nums)</span><br><span class="line">    .boxed()</span><br><span class="line">    .map(e -&gt; e.toString())</span><br><span class="line">    .sorted((e1, e2) -&gt; &#123;</span><br><span class="line">        String s1 &#x3D; e1 + e2;</span><br><span class="line">        String s2 &#x3D; e2 + e1;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; s1.length(); i++)&#123;</span><br><span class="line">            if(s1.charAt(i) - s2.charAt(i) &gt; 0) return -1;</span><br><span class="line">            else if(s1.charAt(i) - s2.charAt(i) &lt; 0) return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;)</span><br><span class="line">    .reduce(String::concat) &#x2F;&#x2F;这里流已经消费完了，下面的filter方法是这个方法返回的Optional类的方法，不要混淆</span><br><span class="line">    .filter(e -&gt; !e.startsWith(&quot;0&quot;))</span><br><span class="line">    .orElse(&quot;0&quot;);</span><br></pre></td></tr></table></figure><p><strong>注：</strong>并行流使用了<a href="D:\TyporaDocument\Java\多线程\ForkJoin框架.md">ForkJoin</a>框架</p><h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><p>当一个流调用parallel()方法时就会变成并行流</p><h4 id="parallel"><a href="#parallel" class="headerlink" title="parallel()"></a>parallel()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> S <span class="title">parallel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sourceStage.parallel = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> (S) <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个方法很简单地把流头stage的parallel标记置为true。然后在执行的时候再来做判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;R&gt; <span class="function">R <span class="title">evaluate</span><span class="params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">getOutputShape</span><span class="params">()</span> </span>== terminalOp.inputShape();</span><br><span class="line">    <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isParallel()</span><br><span class="line">        ? terminalOp.evaluateParallel(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()))</span><br><span class="line">        : terminalOp.evaluateSequential(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是判断流头结点的parallel标记，如果为true，就走并行执行的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;S&gt; <span class="function">Void <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Spliterator&lt;S&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ordered)</span><br><span class="line">        <span class="keyword">new</span> ForEachOrderedTask&lt;&gt;(helper, spliterator, <span class="keyword">this</span>).invoke();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ForEachTask&lt;&gt;(helper, spliterator, helper.wrapSink(<span class="keyword">this</span>)).invoke();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并行执行</p><ul><li><p>如果不需要保持顺序，那么就直接把相关数据包装成一个ForkJoinTask，包装时执行了包装Sink的操作。</p><p>ForkJoinTask里面同时封装好了compute方法：任务分割的逻辑。使用Fork/Join框架来执行这个任务。<strong>这也是为什么需要可分割迭代器（Spliterator）作为数据源的原因</strong>。因为ForkJoinTask在执行的过程中会分割，正好使用Spliterator的特性。</p></li><li><p>需要保持顺序的话，也是封装成一个ForkJoinTask。（这个逻辑里，包装Sink是在任务执行的时候进行的）。但是在任务fork的过程中，<strong>会使用一个ConcurrentHashMap来记录任务的顺序</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/10/30/hello-world/"/>
      <url>2020/10/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
